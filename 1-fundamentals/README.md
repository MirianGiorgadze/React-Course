## პროექტის ჩამოწერა და გაშვება
პროექტის გასაშვებად უნდა ჩამოტვირთოთ git რეპო,
უნდა შეხვიდეთ ფოლდერში და cmd-ში გაუშვათ ეს ბრძანებები:
- პირველი ბრძანება ემსახურება პროექტის ფოლდერში შესვლას
- მეორე ბრძანება ემსახურება package.json-ში მოთავსებული მოდულების დაყენებას
- მესამე ბრძანება ემსახურება პროექტის გაშვებას dev რეჟიმში

```cmd
cd 1-fundamentals
npm install 
npm run dev
```

### რა კრიტერიუმებს უნდა აკმაყოფილებდეს კომპონენტი:

- იწყებოდეს ასომთავრულეად
- უნდა აბრუნებდეს html-ს ერთი მშობელი ელემენტით (ან ფრაგმენტით <> რომელიც არ ქმნის ახალ კვანძებს DOM ხე-ში)
- უნდა დავიცვათ JSX წესები 

### JSX წესები
- camelCase ატრიბუტები
- ატრიბუტი className class-ის ნაცვლად
- ატრიბუტი htmlFor for-ის ნაცვლად
- ყველა ელემენტი უნდა იყოს დახურული, მათ შორის void ელემენტებიც 
- JS კოდის შეტანა შეგვიძლია ფიგურულ ფრჩხილებში - '{}'

#### ხაზისშიდა inline გასტილვა
- ამისთვის გამოიყენება style პროპი
- {} ფიგურული ფრჩხილებით გადავდივართ JS გარემოში
- ამ გარემოში ვამატებთ object-ს და ვამატებთ css property და valueb-ს key-value პრინციპით.

მაგალითი:
```jsx
    <h4 style={{color: "red", backgroundColor: "yellow"}}>
        Hello
    </h4>
```

### prop-ები (Properties)

Prop-ები React-ში კომპონენტებს შორის მონაცემების გადაცემის ძირითადი საშუალებაა. ისინი ფუნქციის პარამეტრებივით მუშაობენ და კომპონენტებს საშუალებას აძლევენ, მიიღონ მონაცემები მშობელი კომპონენტიდან.

#### Prop - ძირითადი მახასიათებლები:
- props-ის მნიშვნელობები შვილობილ კომპონენტში არ უნდა შეიცვალოს.
- ისინი მხოლოდ მშობელმა კომპონენტმა უნდა განსაზღვროს.
- გამოიყენება სტრინგების, რიცხვების, ფუნქციების და ობიექტების გადაცემისთვის.

მაგალითად:

```jsx
const Greeting = (props) => {
  return <h1>გამარჯობა, {props.name}!</h1>;
};

const App = () => {
  return <Greeting name="ნიკა" />;
};
```
ამ კოდში name="ნიკა" მნიშვნელობა მშობელმა კომპონენტმა (App) გადასცა შვილობილ Greeting კომპონენტს props-ის სახით.

#### children prop
children არის სპეციალური prop, რომელსაც React ავტომატურად გადასცემს კომპონენტს – ეს არის ყველა ის ელემენტი ან კონტენტი, რაც წერია კომპონენტის გახსნასა და დახურვას შორის.

მაგალითისთვის:
```jsx
export default function UserPost(props){
    // const {author, title, uploadDate, children} = props
    return(
        <div className="user-post">
            <h3>{props.title}</h3>
            {props.children}
            <h5><b>Author:</b> {props.author}</h5>
            <p>Uploaded on {props.uploadDate}</p>
            
        </div>
    )
}
```
UserPost კომპონენტის გახსნა-დახურვას შორის მოთავსებული შიგთავსი დაიბეჭდება  h3 და h5 ელემენტებს შორის,
რადგან {props.children} მოთავსებულია ამ წერტილში.

### კლას კომპონენტი
კლას კომპონენტი მსგავსად მუშაობს როგორც ფუნქციონალური კომპონენტები, იმ განსხვავებით, რომ იყენებს render
მეთოდს.


```jsx
class FruitsList extends Component {
  render() {
    const fruits = ['ვაშლი', 'ბანანი', 'ატამი'];

    return (
      <div className="fruits-container">
        <h2>ხილის სია</h2>
        <ul className="fruits-list">
          {fruits.map((fruit, index) => (
            <li key={index} className="fruit-item">{fruit}</li>
          ))}
        </ul>
      </div>
    );
  }
}
```


### სიების გამოყენება
users ცვლადში მოცემულია მომხმარებლების სია.
map ფუნქციის გამოყენებით შეგვიძლია თითოეული მათგანის შესახებ ინფორმაციის დაბეჭდვა.
ამისთვის აუცილებელია, რომ map ფუნქციას გადავცეთ მეორე პარამეტრი index - რომელიც იქნება 
უნიკალური ატრიბუტი key-ის მნიშვნელობა რენდერისას. 
key ატრიბუტის მითითების გარეშე ჩვენ ვერ შევძლებთ გამოვსახოთ ელემენტები.

```jsx
class UsersList extends Component {
  render() {
    const users = [
        {firstName: "ლაშა", lastName: "მოსიძე"}, 
        {firstName: "საბა", lastName: "აბუსელიძე"}, 
        {firstName: "ლაშა", lastName: "ბერიძე"}
    ];

    return (
      <div className="fruits-container">
        <h2>მომხმარებლების სია</h2>
        <ul className="fruits-list">
          {users.map((user, index) => (
            <li key={index} className="fruit-item">{user.firstName} {user.lastName}</li>
          ))}
        </ul>
      </div>
    );
  }
}
export default UsersList;
```
### კომპონენტის სიცოცხლის ციკლი

#### -mount(render)
ხდება კომპონენტის საწყისი ჩატვირთვისას
#### -update(re-render)
ხდება props-ის ან state-ის შეცვლისას
#### -unmount
ხდება კომპონენტის გაქრობისას

### useEffect ჰუკი

useEffect არის რეაქტის ჰუკი, რომელიც საშუალებას გაძლევს
შეასრულო გვერდითი სამუშაოები, რომელიც არის კომპონენტს გარეთ.
იგი ხშირად გამოიყენება ისეთი სამუშაოებისთვის, როგორიცაა
მონაცემების წაკითხვა, DOM-ის განახლება, ივენთებთან მუშაობა და ა.შ

- გააჩნია ორი არგუმენტი (მეორე არ არის სავალდებულო)
- პირველი არგუმენტი - callBack ფუნქცია
- მეორე არგუმენტი - დამოკიდებულებების მასივი
- default შემთხვევაში cb ფუნქცია გაეშვება საწყისი რენდერისა და re-რენდერის დროს
- თუ მეორე არგუმენტი არის ცარიელი მასივი [], გაეშვება მხოლოდ საწყისი რენდერისას
- არგუმენტად გადაცემული cb ფუნქცია არ უნდა აბრუნებდეს promise-ს.